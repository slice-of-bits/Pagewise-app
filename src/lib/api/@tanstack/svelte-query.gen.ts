// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, type MutationOptions, queryOptions } from '@tanstack/svelte-query';

import { client } from '../client.gen';
import { bucketApiCreateBucket, bucketApiDeleteBucket, bucketApiGetBucket, bucketApiListBuckets, bucketApiUpdateBucket, documentsApiCreateDocument, documentsApiDeleteDocument, documentsApiGetDoclingSettings, documentsApiGetDocument, documentsApiGetDocumentProgress, documentsApiGetImage, documentsApiGetPage, documentsApiGetPageImages, documentsApiListDocuments, documentsApiListPages, documentsApiSearchPages, documentsApiUpdateDoclingSettings, documentsApiUpdateDocument, documentsApiUpdatePage, documentsApiUploadDocument, type Options, pagewiseApiHealthCheck } from '../sdk.gen';
import type { BucketApiCreateBucketData, BucketApiCreateBucketResponse, BucketApiDeleteBucketData, BucketApiGetBucketData, BucketApiGetBucketResponse, BucketApiListBucketsData, BucketApiListBucketsResponse, BucketApiUpdateBucketData, BucketApiUpdateBucketResponse, DocumentsApiCreateDocumentData, DocumentsApiCreateDocumentResponse, DocumentsApiDeleteDocumentData, DocumentsApiGetDoclingSettingsData, DocumentsApiGetDoclingSettingsResponse, DocumentsApiGetDocumentData, DocumentsApiGetDocumentProgressData, DocumentsApiGetDocumentResponse, DocumentsApiGetImageData, DocumentsApiGetImageResponse, DocumentsApiGetPageData, DocumentsApiGetPageImagesData, DocumentsApiGetPageImagesResponse, DocumentsApiGetPageResponse, DocumentsApiListDocumentsData, DocumentsApiListDocumentsResponse, DocumentsApiListPagesData, DocumentsApiListPagesResponse, DocumentsApiSearchPagesData, DocumentsApiSearchPagesResponse, DocumentsApiUpdateDoclingSettingsData, DocumentsApiUpdateDoclingSettingsResponse, DocumentsApiUpdateDocumentData, DocumentsApiUpdateDocumentResponse, DocumentsApiUpdatePageData, DocumentsApiUpdatePageResponse, DocumentsApiUploadDocumentData, DocumentsApiUploadDocumentResponse, PagewiseApiHealthCheckData } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const pagewiseApiHealthCheckQueryKey = (options?: Options<PagewiseApiHealthCheckData>) => createQueryKey('pagewiseApiHealthCheck', options);

/**
 * Health Check
 */
export const pagewiseApiHealthCheckOptions = (options?: Options<PagewiseApiHealthCheckData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof pagewiseApiHealthCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await pagewiseApiHealthCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: pagewiseApiHealthCheckQueryKey(options)
});

export const bucketApiListBucketsQueryKey = (options?: Options<BucketApiListBucketsData>) => createQueryKey('bucketApiListBuckets', options);

/**
 * List Buckets
 *
 * Get all buckets
 */
export const bucketApiListBucketsOptions = (options?: Options<BucketApiListBucketsData>) => queryOptions<BucketApiListBucketsResponse, DefaultError, BucketApiListBucketsResponse, ReturnType<typeof bucketApiListBucketsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await bucketApiListBuckets({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: bucketApiListBucketsQueryKey(options)
});

/**
 * Create Bucket
 *
 * Create a new bucket
 */
export const bucketApiCreateBucketMutation = (options?: Partial<Options<BucketApiCreateBucketData>>): MutationOptions<BucketApiCreateBucketResponse, DefaultError, Options<BucketApiCreateBucketData>> => {
    const mutationOptions: MutationOptions<BucketApiCreateBucketResponse, DefaultError, Options<BucketApiCreateBucketData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await bucketApiCreateBucket({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Bucket
 *
 * Delete a bucket
 */
export const bucketApiDeleteBucketMutation = (options?: Partial<Options<BucketApiDeleteBucketData>>): MutationOptions<unknown, DefaultError, Options<BucketApiDeleteBucketData>> => {
    const mutationOptions: MutationOptions<unknown, DefaultError, Options<BucketApiDeleteBucketData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await bucketApiDeleteBucket({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bucketApiGetBucketQueryKey = (options: Options<BucketApiGetBucketData>) => createQueryKey('bucketApiGetBucket', options);

/**
 * Get Bucket
 *
 * Get a specific bucket by sqid
 */
export const bucketApiGetBucketOptions = (options: Options<BucketApiGetBucketData>) => queryOptions<BucketApiGetBucketResponse, DefaultError, BucketApiGetBucketResponse, ReturnType<typeof bucketApiGetBucketQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await bucketApiGetBucket({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: bucketApiGetBucketQueryKey(options)
});

/**
 * Update Bucket
 *
 * Update a bucket
 */
export const bucketApiUpdateBucketMutation = (options?: Partial<Options<BucketApiUpdateBucketData>>): MutationOptions<BucketApiUpdateBucketResponse, DefaultError, Options<BucketApiUpdateBucketData>> => {
    const mutationOptions: MutationOptions<BucketApiUpdateBucketResponse, DefaultError, Options<BucketApiUpdateBucketData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await bucketApiUpdateBucket({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const documentsApiListDocumentsQueryKey = (options?: Options<DocumentsApiListDocumentsData>) => createQueryKey('documentsApiListDocuments', options);

/**
 * List Documents
 *
 * Get all documents, optionally filtered by bucket
 */
export const documentsApiListDocumentsOptions = (options?: Options<DocumentsApiListDocumentsData>) => queryOptions<DocumentsApiListDocumentsResponse, DefaultError, DocumentsApiListDocumentsResponse, ReturnType<typeof documentsApiListDocumentsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiListDocuments({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiListDocumentsQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const documentsApiListDocumentsInfiniteQueryKey = (options?: Options<DocumentsApiListDocumentsData>): QueryKey<Options<DocumentsApiListDocumentsData>> => createQueryKey('documentsApiListDocuments', options, true);

/**
 * List Documents
 *
 * Get all documents, optionally filtered by bucket
 */
export const documentsApiListDocumentsInfiniteOptions = (options?: Options<DocumentsApiListDocumentsData>) => infiniteQueryOptions<DocumentsApiListDocumentsResponse, DefaultError, InfiniteData<DocumentsApiListDocumentsResponse>, QueryKey<Options<DocumentsApiListDocumentsData>>, number | Pick<QueryKey<Options<DocumentsApiListDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<DocumentsApiListDocumentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await documentsApiListDocuments({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiListDocumentsInfiniteQueryKey(options)
});

/**
 * Create Document
 *
 * Create a new document
 */
export const documentsApiCreateDocumentMutation = (options?: Partial<Options<DocumentsApiCreateDocumentData>>): MutationOptions<DocumentsApiCreateDocumentResponse, DefaultError, Options<DocumentsApiCreateDocumentData>> => {
    const mutationOptions: MutationOptions<DocumentsApiCreateDocumentResponse, DefaultError, Options<DocumentsApiCreateDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await documentsApiCreateDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Upload Document
 *
 * Upload a PDF document and start processing
 */
export const documentsApiUploadDocumentMutation = (options?: Partial<Options<DocumentsApiUploadDocumentData>>): MutationOptions<DocumentsApiUploadDocumentResponse, DefaultError, Options<DocumentsApiUploadDocumentData>> => {
    const mutationOptions: MutationOptions<DocumentsApiUploadDocumentResponse, DefaultError, Options<DocumentsApiUploadDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await documentsApiUploadDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Document
 *
 * Delete a document
 */
export const documentsApiDeleteDocumentMutation = (options?: Partial<Options<DocumentsApiDeleteDocumentData>>): MutationOptions<unknown, DefaultError, Options<DocumentsApiDeleteDocumentData>> => {
    const mutationOptions: MutationOptions<unknown, DefaultError, Options<DocumentsApiDeleteDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await documentsApiDeleteDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const documentsApiGetDocumentQueryKey = (options: Options<DocumentsApiGetDocumentData>) => createQueryKey('documentsApiGetDocument', options);

/**
 * Get Document
 *
 * Get a specific document by sqid
 */
export const documentsApiGetDocumentOptions = (options: Options<DocumentsApiGetDocumentData>) => queryOptions<DocumentsApiGetDocumentResponse, DefaultError, DocumentsApiGetDocumentResponse, ReturnType<typeof documentsApiGetDocumentQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiGetDocument({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiGetDocumentQueryKey(options)
});

/**
 * Update Document
 *
 * Update a document
 */
export const documentsApiUpdateDocumentMutation = (options?: Partial<Options<DocumentsApiUpdateDocumentData>>): MutationOptions<DocumentsApiUpdateDocumentResponse, DefaultError, Options<DocumentsApiUpdateDocumentData>> => {
    const mutationOptions: MutationOptions<DocumentsApiUpdateDocumentResponse, DefaultError, Options<DocumentsApiUpdateDocumentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await documentsApiUpdateDocument({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const documentsApiGetDocumentProgressQueryKey = (options: Options<DocumentsApiGetDocumentProgressData>) => createQueryKey('documentsApiGetDocumentProgress', options);

/**
 * Get Document Progress
 *
 * Get document processing progress
 */
export const documentsApiGetDocumentProgressOptions = (options: Options<DocumentsApiGetDocumentProgressData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof documentsApiGetDocumentProgressQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiGetDocumentProgress({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiGetDocumentProgressQueryKey(options)
});

export const documentsApiListPagesQueryKey = (options?: Options<DocumentsApiListPagesData>) => createQueryKey('documentsApiListPages', options);

/**
 * List Pages
 *
 * Get all pages, optionally filtered by document
 */
export const documentsApiListPagesOptions = (options?: Options<DocumentsApiListPagesData>) => queryOptions<DocumentsApiListPagesResponse, DefaultError, DocumentsApiListPagesResponse, ReturnType<typeof documentsApiListPagesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiListPages({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiListPagesQueryKey(options)
});

export const documentsApiListPagesInfiniteQueryKey = (options?: Options<DocumentsApiListPagesData>): QueryKey<Options<DocumentsApiListPagesData>> => createQueryKey('documentsApiListPages', options, true);

/**
 * List Pages
 *
 * Get all pages, optionally filtered by document
 */
export const documentsApiListPagesInfiniteOptions = (options?: Options<DocumentsApiListPagesData>) => infiniteQueryOptions<DocumentsApiListPagesResponse, DefaultError, InfiniteData<DocumentsApiListPagesResponse>, QueryKey<Options<DocumentsApiListPagesData>>, number | Pick<QueryKey<Options<DocumentsApiListPagesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<DocumentsApiListPagesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await documentsApiListPages({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiListPagesInfiniteQueryKey(options)
});

export const documentsApiGetPageQueryKey = (options: Options<DocumentsApiGetPageData>) => createQueryKey('documentsApiGetPage', options);

/**
 * Get Page
 *
 * Get a specific page by sqid
 */
export const documentsApiGetPageOptions = (options: Options<DocumentsApiGetPageData>) => queryOptions<DocumentsApiGetPageResponse, DefaultError, DocumentsApiGetPageResponse, ReturnType<typeof documentsApiGetPageQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiGetPage({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiGetPageQueryKey(options)
});

/**
 * Update Page
 *
 * Update a page
 */
export const documentsApiUpdatePageMutation = (options?: Partial<Options<DocumentsApiUpdatePageData>>): MutationOptions<DocumentsApiUpdatePageResponse, DefaultError, Options<DocumentsApiUpdatePageData>> => {
    const mutationOptions: MutationOptions<DocumentsApiUpdatePageResponse, DefaultError, Options<DocumentsApiUpdatePageData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await documentsApiUpdatePage({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const documentsApiGetPageImagesQueryKey = (options: Options<DocumentsApiGetPageImagesData>) => createQueryKey('documentsApiGetPageImages', options);

/**
 * Get Page Images
 *
 * Get all images from a specific page
 */
export const documentsApiGetPageImagesOptions = (options: Options<DocumentsApiGetPageImagesData>) => queryOptions<DocumentsApiGetPageImagesResponse, DefaultError, DocumentsApiGetPageImagesResponse, ReturnType<typeof documentsApiGetPageImagesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiGetPageImages({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiGetPageImagesQueryKey(options)
});

export const documentsApiGetImageQueryKey = (options: Options<DocumentsApiGetImageData>) => createQueryKey('documentsApiGetImage', options);

/**
 * Get Image
 *
 * Get a specific image by sqid
 */
export const documentsApiGetImageOptions = (options: Options<DocumentsApiGetImageData>) => queryOptions<DocumentsApiGetImageResponse, DefaultError, DocumentsApiGetImageResponse, ReturnType<typeof documentsApiGetImageQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiGetImage({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiGetImageQueryKey(options)
});

export const documentsApiSearchPagesQueryKey = (options?: Options<DocumentsApiSearchPagesData>) => createQueryKey('documentsApiSearchPages', options);

/**
 * Search Pages
 *
 * Search pages using PostgreSQL text matching and similarity
 */
export const documentsApiSearchPagesOptions = (options?: Options<DocumentsApiSearchPagesData>) => queryOptions<DocumentsApiSearchPagesResponse, DefaultError, DocumentsApiSearchPagesResponse, ReturnType<typeof documentsApiSearchPagesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiSearchPages({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiSearchPagesQueryKey(options)
});

export const documentsApiGetDoclingSettingsQueryKey = (options?: Options<DocumentsApiGetDoclingSettingsData>) => createQueryKey('documentsApiGetDoclingSettings', options);

/**
 * Get Docling Settings
 *
 * Get current Docling settings
 */
export const documentsApiGetDoclingSettingsOptions = (options?: Options<DocumentsApiGetDoclingSettingsData>) => queryOptions<DocumentsApiGetDoclingSettingsResponse, DefaultError, DocumentsApiGetDoclingSettingsResponse, ReturnType<typeof documentsApiGetDoclingSettingsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await documentsApiGetDoclingSettings({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentsApiGetDoclingSettingsQueryKey(options)
});

/**
 * Update Docling Settings
 *
 * Update Docling settings
 */
export const documentsApiUpdateDoclingSettingsMutation = (options?: Partial<Options<DocumentsApiUpdateDoclingSettingsData>>): MutationOptions<DocumentsApiUpdateDoclingSettingsResponse, DefaultError, Options<DocumentsApiUpdateDoclingSettingsData>> => {
    const mutationOptions: MutationOptions<DocumentsApiUpdateDoclingSettingsResponse, DefaultError, Options<DocumentsApiUpdateDoclingSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await documentsApiUpdateDoclingSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
